[{"title":"爬墙头后无法使用PowerShell(windows10)或者iterm(Mac OS)愉快的同性交友","date":"2021-06-17T11:36:27.000Z","path":"2021/06/17/代理/爬墙头后无法使用powershell-windows10-或者iterm-mac-os-愉快的同性交友/","text":"最近遇到了个问题，就是明明翻过了墙头，无论用 PowerShell 还是 iterm ，通过命令行来愉快的同性交友。就是各种 443 或者 Timed out 。仔细的翻了下，找到了解决办法，分享给大家。 # Mac 非 root 用户下 1vim ~/.bash_profile 在文件里面添加以下 123export https_proxy=http://127.0.0.1:7890export http_proxy=http://127.0.0.1:7890export all_proxy=socks5://127.0.0.1:7890 退出编辑后， source 一下即可。 root 用户下 1vim ~/.zshrc 在文件里面添加以下 123export https_proxy=http://127.0.0.1:7890export http_proxy=http://127.0.0.1:7890export all_proxy=socks5://127.0.0.1:7890 退出编辑后， source 一下即可。 PS: 我的 Mac 在 root 下是没有 .zshrc 文件的，我是自己手动在 ~/ 目录下创建的。如果没有的老铁们可以参考一下我的做法。还有就是上面的 7890 端口，这个端口是我的梯子用的端口，并不是都是 7890 端口的。这一点尤为注意。 # Windows PowerShell 在 windows 下，场景又变的不一样了。 windows 自带的终端我是没有使用的。 我是在 Microsoft Store 里面安装的 Power Shell ，这个怎么设置代理呢。 需要在 我的电脑 的 文档 里面找到一个文件夹，这个文件夹可能叫 PowerShell 也可能叫 WindowsPowerShell 。 在文件夹里面创建一个文件 Microsoft.PowerShell_profile.ps1 在文件里面添加如下 12345$env:HTTPS_PROXY=&quot;http://127.0.0.1:52091&quot;$env:HTTP_PROXY=&quot;http://127.0.0.1:52091&quot;$env:all_proxy=&quot;socks5://127.0.0.1:52092&quot; 不需要像 Mac 一样 source ，直接保存退出，重启 Power Shell 即可。 嗯，享受伟大的同性交友吧～～～","link":"","categories":[{"name":"Shell","slug":"Shell","permalink":"https://hubao-1125.github.io/categories/Shell/"},{"name":"proxy","slug":"proxy","permalink":"https://hubao-1125.github.io/categories/proxy/"},{"name":"代理","slug":"代理","permalink":"https://hubao-1125.github.io/categories/%E4%BB%A3%E7%90%86/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://hubao-1125.github.io/tags/Shell/"},{"name":"proxy","slug":"proxy","permalink":"https://hubao-1125.github.io/tags/proxy/"},{"name":"代理","slug":"代理","permalink":"https://hubao-1125.github.io/tags/%E4%BB%A3%E7%90%86/"}]},{"title":"Hello World","date":"2021-06-17T11:29:25.868Z","path":"2021/06/17/uncategorized/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. # Quick Start # Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing # Run server 1$ hexo server More info: Server # Generate static files 1$ hexo generate More info: Generating # Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"","categories":[],"tags":[]},{"title":"脸书三方登录对接（后端）","date":"2021-06-12T08:55:07.000Z","path":"2021/06/12/oversea/脸书三方登录对接（后端）/","text":"嗯，接之前写的谷歌对接，这次是脸书对接。对接脸书也是挺难的，当时翻遍了脸书的 API 文档，死活没找到相关的，而且是纯英文。最后还是找到了。脸书对接不需要引包，脸书对接是直接发 GET 请求就可以。 1234567891011121314151617String appID = &quot;123&quot;;String accessToken = &quot;access_token=&quot;;String appSecret = &quot;asdasdjajsdjasj&quot;;String yu = &quot;%7c&quot;;String inputToken = &quot;input_token=&quot;;String debugTokenURL = &quot;https://graph.facebook.com/debug_token?&quot;;// 拼凑请求参数String reqURL = debugTokenURL + accessToken + appID + yu + appSecret + &quot;&amp;&quot; + inputToken + reqVO.getIDToken();logger.info(&quot;faceBookCheckIDTokenReq:::&quot; + &quot;:::&quot; + reqURL);String body = HttpRequest.get(reqURL).timeout(5000).execute().body();logger.info(&quot;faceBookCheckIDTokenRes:::&quot; + &quot;:::&quot; + body);JSONObject jsonObject = JSON.parseObject(body);JSONObject data = jsonObject.getJSONObject(&quot;data&quot;);Boolean is_valid = data.getBoolean(&quot;is_valid&quot;);if (is_valid == null || !is_valid) &#123; logger.info(400, &quot;ID Token valid fail&quot;);&#125; 脸书校验 token 就是一个地址 GET 请求足矣。 https://graph.facebook.com/debug_token?access_token={App-token}&amp;input_token= App-token 其实是 应用ID 与 应用密钥 组成的，中间加个 UrlEncode 后的 | 组成的。 | 在 UrlEncode 后是 %7c User-token 就是前端通过 SDK 获取到的用户 token 比如我的 APPID 是 123，密钥是 456，用户 token 是 789，那么完整的请求地址如下： https://graph.facebook.com/debug_token?access_token=123|456&amp;input_token=789 就用上面的地址发起 GET 请求就好。我代码里面 HttpRequest 请求起来是不是特别方便？这里安利一波国人开源的 Java 工具 Hutool , 相关地址在下面啦，也算是帮作者推广推广～～～ 官网：https://hutool.cn/ Github：https://github.com/dromara/hutool/ Gitee：https://gitee.com/dromara/hutool/","link":"","categories":[{"name":"Java","slug":"Java","permalink":"https://hubao-1125.github.io/categories/Java/"},{"name":"oversea","slug":"oversea","permalink":"https://hubao-1125.github.io/categories/oversea/"}],"tags":[{"name":"三方登录","slug":"三方登录","permalink":"https://hubao-1125.github.io/tags/%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"},{"name":"Java","slug":"Java","permalink":"https://hubao-1125.github.io/tags/Java/"},{"name":"oversea","slug":"oversea","permalink":"https://hubao-1125.github.io/tags/oversea/"},{"name":"facebook","slug":"facebook","permalink":"https://hubao-1125.github.io/tags/facebook/"}]},{"title":"谷歌三方登录对接（后端）","date":"2021-06-12T08:36:17.000Z","path":"2021/06/12/oversea/谷歌三方登录对接（后端）/","text":"最近公司给派任务啦，海外业务线 C 端上要对接 谷歌 与 脸书 的三方对接。于是，我先百度，百度了一圈发现，一个能打的都没有，都是抄，完了还没后端的对接。这就比较烦了，于是花了点时间自己跟前端联调，调通了。在这里分享给大家。 废话不多说，上代码。 123456789101112131415161718192021222324252627282930313233343536&lt;!-- google third login api --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.api-client&lt;/groupId&gt; &lt;artifactId&gt;google-api-client&lt;/artifactId&gt; &lt;version&gt;1.31.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.oauth-client&lt;/groupId&gt; &lt;artifactId&gt;google-oauth-client&lt;/artifactId&gt; &lt;version&gt;1.31.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.http-client&lt;/groupId&gt; &lt;artifactId&gt;google-http-client&lt;/artifactId&gt; &lt;version&gt;1.39.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.findbugs&lt;/groupId&gt; &lt;artifactId&gt;jsr305&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;3.15.3&lt;/version&gt; &lt;/dependency&gt; 这是用的谷歌官方的一些包。 官方文档：https://developers.google.com/identity/sign-in/android/start 谷歌登录是需要各个端的 ClientID ，这个 ClientID 是前后端都需要的。比如，我们是要求 PC 、 安卓 、 IOS 都要对接的，按照谷歌官方文档指引，去创建对应应用以及应用的 ClientID 后要把这些 ID 存起来，如果是 SAAS 系统的话，则需要落库了，我们的海外不是 SAAS 的就直接写死在代码里面了。下面是代码 12345678910111213141516171819202122232425262728293031323334353637 List&lt;String&gt; clientIDList = new ArrayList&lt;&gt;(); // IOS clientIDList.add(&quot;xxxxxxxxxx.apps.googleusercontent.com&quot;); // 安卓 clientIDList.add(&quot;xxxxxxxxxx.apps.googleusercontent.com&quot;); // Web Application 这个是给网页用的 clientIDList.add(&quot;xxxxxxxxxx.apps.googleusercontent.com&quot;); try &#123; GoogleIdTokenVerifier verifier = new GoogleIdTokenVerifier.Builder(new NetHttpTransport(), GsonFactory.getDefaultInstance()) .setAudience(clientIDList) .build();// verifier这个对象别打印，打印会报错 GoogleIdToken idToken = verifier.verify(reqVO.getIDToken()); logger.info(&quot;googleVerifyRes:::&quot; + &quot;:::&quot; + JSON.toJSONString(idToken)); if (idToken != null) &#123; GoogleIdToken.Payload payload = idToken.getPayload(); logger.info(&quot;googleGoogleIdToken.Payload:::&quot; + &quot;:::&quot; + JSON.toJSONString(payload)); // 用户在谷歌的唯一ID String userId = payload.getSubject(); System.out.println(&quot;User ID: &quot; + userId); // 用户的邮箱 String email = payload.getEmail(); boolean emailVerified = Boolean.valueOf(payload.getEmailVerified()); // 用户的姓名 String name = (String) payload.get(&quot;name&quot;); // 用户在谷歌的头像地址 String pictureUrl = (String) payload.get(&quot;picture&quot;); // 用户的所在地 String locale = (String) payload.get(&quot;locale&quot;); // 用户的家人姓名 String familyName = (String) payload.get(&quot;family_name&quot;); // 用户的教名 String givenName = (String) payload.get(&quot;given_name&quot;); &#125; else&#123; logger.info(&quot;ID Token valid fail&quot;); &#125; 有了 pom 的引用包跟上面的代码，就足够了，这个主要是前端传递给后端用户的 ID 令牌，后端校验是否是一个合法的用户，得到用户的 user_id 跟 picture 就可以跟我们的业务的用户信息做处理了。嗯，就挺简单的，趟坑简直了！！！","link":"","categories":[{"name":"Java","slug":"Java","permalink":"https://hubao-1125.github.io/categories/Java/"},{"name":"oversea","slug":"oversea","permalink":"https://hubao-1125.github.io/categories/oversea/"}],"tags":[{"name":"google","slug":"google","permalink":"https://hubao-1125.github.io/tags/google/"},{"name":"三方登录","slug":"三方登录","permalink":"https://hubao-1125.github.io/tags/%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"},{"name":"Java","slug":"Java","permalink":"https://hubao-1125.github.io/tags/Java/"},{"name":"oversea","slug":"oversea","permalink":"https://hubao-1125.github.io/tags/oversea/"}]},{"title":"buildHexoShoka","date":"2021-05-03T14:50:10.000Z","path":"2021/05/03/Hexo/buildhexoshoka/","text":"# shoka hexo 插件 1、 https://github.com/amehime/hexo-renderer-multi-markdown-it 123npm un hexo-renderer-marked --savenpm i hexo-renderer-multi-markdown-it --save 2、 https://github.com/hexojs/hexo-autoprefixer 1npm install hexo-autoprefixer --save 3、 https://github.com/LouisBarranqueiro/hexo-algoliasearch https://www.algolia.com/ 1npm install hexo-algoliasearch --save 4、 https://github.com/theme-next/hexo-symbols-count-time 1npm install hexo-symbols-count-time 5、 https://github.com/sergeyzwezdin/hexo-feed 1npm install hexo-feed --save-dev","link":"","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hubao-1125.github.io/categories/Hexo/"}],"tags":[{"name":"shoka","slug":"shoka","permalink":"https://hubao-1125.github.io/tags/shoka/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hubao-1125.github.io/tags/Hexo/"}]}]